Chapter 2. 변수

# 기본형(primitive type)

</br>

## 4.1 논리형 - boolean

논리형에는 `boolean` 한 가지 밖에 없다. `boolean`형 변수에는 `true`와 `false` 중 하나를 저장할 수 있으며 기본값(default)은 `false`이다.

`boolean`형 변수는 대답(yes/no), 스위치(on/off) 등의 논리구현에 주로 사용된다. 그리고 `boolean`형은 `true`와 `false`, 두 가지의 값만을 표현하면 되므로 1 bit만으로도 충분하지만, 자바에서는 데이터를 다루는 최소단위가 byte이기 때문에, `boolean`의 크기가 1 byte이다. 아래 문장은 `power`라는 `boolean`형 변수를 선언하고 `true`로 변수를 초기화 했다.

``` java
boolean power = true;
boolean checked = False;    // 에러, 대소문자가 구분됨. true 또는 false만 가능
```

자바에서는 대소문자가 구별되기 때문에 TRUE와 true는 다른 것으로 간주된다는 것에 주의해야 한다.

</br>

## 4.2 문자형 - char

문자형 역시 `char` 한 가지로 자료형밖에 없다. 문자를 저장하기 위한 변수를 선언할 때 사용되며, `char` 타입의 변수는 단 하나의 문자만을 저장할 수 있다. 아래 문장은 `char`타입의 변수 `ch`를 선언하고, 문자 'A'로 초기화한다.

``` java
char ch = 'A';  // 문자 'A'를 char 타입의 변수 ch에 저장
```

위의 문장은 변수에 '문자'가 저장되는 같지만, 사실은 문자가 아닌 '문자의 유니코드(정수)'가 저장된다. 컴퓨터는 숫자밖에 모르기 때문에 모든 데이터를 숫자로 변환하여 저장하는 것이다.

그래서 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다. 문자 'A'의 유니코드는 10진수로 65이며, 아래의 두 문장은 동일한 결과를 얻는다.

``` java
char ch = 'A';  // 문자 'A'를 char타입의 변수 ch에 저장
char ch = 65;   // 문자의 코드를 직접 변수 ch에 저장
```

만일 어떤 무나의 유니코드를 알고 싶으면, `char`형 변수에 저장된 값을 정수형(int)으로 변환하면 된다.

``` java
int code = (int)ch; // ch에 저장된 값을 int타입으로 변환하여 저장한다.
```

어떤 타입(type, 형)을 다른 타입으로 변환하는 것을 형변환(캐스팅, casting)이라고 한다.

예제 2-7 / ch2 / CharToCode.java
``` java
public class CharToCode {

	public static void main(String[] args) {
		char ch = 'A';	// char ch = 65;
		int code = (int)ch;	// ch에 저장된 값을 int타입으로 변환하여 저장한다.
		
		System.out.printf("%c=%d(%#X)%n", ch, code, code);
		
		char hch = '가';	// char hch = 0xAC00;
		System.out.printf("%c=%d(%#X)%n", hch, (int)hch, (int)hch);
	}

}

```

```
A=65(0X41)
가=44032(0XAC00)
```

실행결과를 보면, 문자 'A'의 유니코드는 65(16진수로 0x41)이고, 문자 '가'의 유니코드는 44032(16진수로 0xAC00)이라는 것을 알 수 있다. 유니코드를 알면 아래와 같이 `char`형 변수에 문자를 저장할 때, 문자 리터럴 대신에 유니코드를 직접 사용할 수도 있다.

``` java
char hch = 0xAc00;  // char hch = '가';
char hch = '\uAC00';    // 이렇게도 가능
```

### 특수 문자 다루기

영문자 이외에 tab이나 backspace 등의 특수문자를 저장하려면, 아래와 같이 조금 특별한 방법을 사용한다.

``` java
char tab = '\t';    // 변수 tab에 탭 문자를 저장
```

`\t`는 실제로는 두 문자로 이루어져 있지만 한 문자(탭, tab)를 의미한다. 아래의 표는 탭(tab)과 같이 특수한 문자를 어떻게 표현할 수 있는지 알려준다.

![image](https://ifh.cc/g/97y3oP.png)

예제 2-8 / ch2 / SpecialCharEx.java
``` java
public class SpecialCharEx {

	public static void main(String[] args) {
		System.out.println('\'');				// '''처럼 할 수 없다.
		System.out.println("abc\t123\b456");	// \b에 의해 3이 지워진다.
		System.out.println('\n');				//  개행(new line) 문자 출력하고 개행
		System.out.println("\"Hello\"");		// 큰따옴표를 출력하려면 이렇게 한다.
		System.out.println("c:\\");
	}

}

```

```
'
abc	123456


"Hello"
c:\
```

### char타입의 표현형식

`char`타입의 크기는 2 byte(=16 bit)이므로, 16자리의 2진수로 표현할 수 있는 정수의 개수인 65536(=2^16)의 코드를 사용할 수 있으며, `char`형 변수는 이 범위 내의 코드 중 하나를 저장할 수 있다.

`char`타입은 문자를 저장할 변수를 선언하기 위한 것이지만, 실제로 `char`타입의 변수에는 문자가 아닌 '문자의 유니코드(정수)'가 저장되고 표현형식 역시 정수형과 동일하다. 다만, 정수형과 달리 음수를 나타낼 필요가 없으므로 표현할 수 있는 값의 범위가 다르다. 2 byte(=16 bit)로는 모두 2^16(=65536)개의 값을 표현할 수 있는데, `char`타입에 저장되는 값인 유니코드는 모두 양수(0 포함)이므로, '0 \~ 65535'의 범위를 가지며, 정수형인 `short`은 절반을 음수표현에 사용하므로 '-32768 \~ 32767'을 범위로 갖는다.

> **16비트로 표현할 수 있는 정수의 개수 : 2^16개(65536개)**   
**short타입의 표현범위 : -2^15 \~ 2^15 - 1 (-32768 \~ 32767)**   
**char타입의 표현범위 : 0 \~ 2^16 - 1 (0 ~ 65535)**

다음과 같이 변수 `ch`와 `s`에 'A'와 65를 저장하면, 둘 다 2진수로 똑같은 값이 저장된다. 컴퓨터는 모든 값을 0과 1로 바꾸어 저장하기 때문이다.

``` java
char ch = 'A';  // char ch = 65;
short s = 65;
```

![image](https://ifh.cc/g/BWL09F.png)

그런데도 두 변수의 값을 출력해보면 결과가 다르다. `println()`은 변수의 타입이 정수형이면 변수에 저장된 값을 10진수로 해석하여 출력하고, 문자형이면 저장된 숫자에 해당한은 유니코드 문자를 출력하기 때문이다.

``` java
System.out.println(ch); // A가 출력된다.
System.out.println(s);  // 65가 출력된다.
```

이처럼 값은 어떻게 해석하느냐에 따라 결과가 달라지므로 값만으로는 값을 해석할 수 없다. 타입까지 알아야 올바르게 해석할 수 있는 것이다.

### 인코딩과 디코딩(encoding & decoding)

문자 'A'를 유니코드로 인코딩하면 65가 된다. 반대로 65를 유니코드로 디코딩하면 문자 'A'가 된다. 이처럼 문자를 코드로 변환하는 것은 '문자 디코딩(decoding)'이라고 하며, 문자를 저장할 때는 인코딩을 해서 숫자로 변환해서 저장하고, 저장된 문자를 읽어올 때는 디코딩을 해서 숫자를 원래의 문자로 되돌려야 한다.

### 아스키(ASCII)

'ASCII'는 'American Standard Code for Information Interchange'의 약어로 정보교환을 위한 미국 표준 코드란 뜻이다. 아스키는 128개(=2^7)의 문자 집합(character set)을 제공하는 7 bit 부호로, 처음 32개의 문자는 인쇄와 전송 제어용으로 사용되는 '제어문자(control character)'로 출력할 수 없고 마지막 문자(DEL)를 제외한 33번째 이후의 문자들은 출력할 수 있는 문자들로, 기호와 숫자, 영대소문자로 이루어져 있다.

### 확장 아스키(Extended ASCII)와 한글
일반적으로 데이터는 byte단위로 다뤄지는데 아스키는 7 bit이므로 1 bit가 남는다. 이 남는 공간을 활용해서 문자를 추가로 정의한 것이 '확장 아스키'이다. 확장 아스키에 추가된 128개의 문자는 여러 국가와 기업에서 서로의 필요에 따라 다르게 정의해서 사용한다.

한글을 표현하는 방법은 조합형과 완성형이 있는데, 조합형은 초성, 중성, 종성을 조합하는 방식이고, 완성형은 확장 아스키의 일부 영역(162 \~ 254)에 해당하는 두 문자코드를 조합하여 한글을 표현한다. 현재 조합형은 사용되지 않고 '완성형(KSC 5601)'에 없는 잘 안쓰이는 8822글자를 추가한 '확장 완성형(CP 949)'이 사용되는데, 이것이 바로 한글 윈도우에서 사용하는 문자 인코딩이다.

### 코드 페이지(code page, cp)

IBM이 자사의 PC에 '확장 아스키'를 도입해서 사용하기 시작할 때, PC를 사용하는 지역이나 국가에 따라 여러 버젼의 '확장 아스키'가 필요했다. IBM은 이들을 '코드 페이지(code page)'라 하고, 각 코드 페이지에 'CP xxx'와 같은 형식으로 이름을 붙였다. IBM은 MS와 같은 업체들과 협력하여 '코드 페이지'를 만들어내고 공유했다. 한글 윈도우는 'CP 949'를, 영문 윈도우는 'CP 437'을 사용한다.

### 유니코드(Unicode)

전 세계의 모든 문자를 하나의 통일된 문자집합으로 표현하고자 노력하였고 그 결과가 바로 '유니코드'이다.

유니코드는 먼저 유니코드에 포함시키고자 하는 문자들의 집합을 정의하였는데, 이것을 유니코드 문자 셋(또는 캐릭터 셋, character set)이라고 한다. 그리고 이 문자 셋에 번호를 붙인 것이 유니코드 인코딩이다. 유니코드 인코딩에는 UTF-8, UTF-16, UTF-32 등 여러 가지 종류가 있는데 자바에서는 UTF-16을 사용한다. uTF-16은 모든 문자를 2 byte의 고정크기로 표현하고 UTF-8은 하나의 문자를 1 \~ 4 byte의 가변크기로 표현한다. 그리고 두 인코딩 모두 처음 128문자가 아스키와 동일하다. 아스키를 그대로 포함하고 있는 것이다.

</br>

## 4.3 정수형 - byte, short, int, long

정수형에는 모두 4개의 자료형이 있으며, 각 자료형이 저장할 수 있는 값의 범위가 서로 다르다. 크기수능로 나열하면 다음과 같다. 단위는 byte이다.

![image](https://ifh.cc/g/9p20mA.png)

`byte`부터 `long`까지 1 byte부터 시작해서 2배씩 크기가 증가한다는 것을 알 수 있다. 이 중에서도 기본 자료형(default data type)은 `int`이다.

### 정수의 표현형식과 범위

어떤 진법의 리터럴을 변수에 저장해도 실제로는 2진수로 바뀌어 저장된다. 이 2진수가 저장되는 형식은 크게 정수형과 실수형이 있으며, 정수형은 달므과 같은 형식으로 저장된다.

![image](https://ifh.cc/g/ZOZLHP.png)

모든 정수형은 부호있는 정수이므로 왼쪽의 첫 번째 비트를 '부호 비트(sign bit)'로 사용하고, 나머지는 값을 표현하는데 사용한다. 그래서 n비트로 표현할 수 있는 값의 개수인 2^n개에서, 절반인 '0'으로 시작하는 2^n-1개의 값을 양수(0도 포함)의 표현에 사용하고, 나머지 절반인 '1'로 시작하는 2^n-1개의 값은 음수의 표현에 사용한다.

![image](https://ifh.cc/g/bl5PO4.png)

> **n비트로 표현할 수 있는 정수의 개수 : 2^n개(= 2^n-1개 + 2^n-1개)**   
**n비트로 표현할 수 있는 부호있는 정수의 범위 : -2^n-1 \~ 2^n-1 - 1**

### 정수형의 선택기준

JVM의 피연산자 스택(operand stack)이 피연산자를 4 byte단위로 저장하기 때문에 크기가 4 byte보다 작은 자료형(`byte`, `short`)의 값을 계산할 때는 4 byte로 변환하여 연산이 수행된다. 그래서 오히려 `int`를 사용하는 것이 더 효율적이다.

`int`타입의 크기는 4 byte(=32 bit)이므로, 표현할 수 있는 정수의 개수는 '2^32 = 4 * 10^7, 약 40억'이며, 표현가능한 정수의 범위는 '-2^31 \~ 2^31 - 1' = 약 +-20억'이다.

결론적으로 **정수형 변수를 선언할 때는 `int`타입으로 하고, `int`의 범위(약 +-20억)를 넘어서는 수를 다뤄야할 때는 `long`을 사용하면 된다.**

> long타입의 범위를 벗어나는 값을 다룰 때는, 실수형 타입이나 `BigInteger`클래스를 사용하면 된다.

### 정수형의 오버플로우

원래 2진수 '1111'에 1을 더하면 '10000'이 되지만, 4 bit로는 4자리의 2진수만 저장할 수 있기 때문에 '0000'이 된다. 즉, 5자리의 2진수 '10000'중에서 하위 4 bit만 저장하게 되는 것이다. 이처럼 연산과정에서 해당 **타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우(overflow)라고 한다. 오버플로우가 발생했다고 해서 에러가 발생하는 것은 아니다. 다만 예상했던 결과를 얻지 못할 뿐이다. 애초부터 오버플로우가 발생하지 않게 충분한 크기의 타입을 선택해서 사용해야 한다.

오버플로우는 정수형 타입이 표현할 수 있는 최대값에 1을 더하면 최소값이 되고, 최소값에서 1을 빼면 최대값이 된다.

> **최대값 + 1 => 최소값**   
**최소값 - 1 => 최대값**

최소값과 최대값을 이어 놓았다고 생각하면 오버플로우의 결과를 더 이해하기 쉽다.

### 부호있는 정수의 오버플로우

부호없는 정수는 2진수로 '0000'이 될 때 오버플로우가 발생하고, **부호있는 정수는 부호비트가 0에서 1이 될 때 오버플로우가 발생한다.**

예제 2-9 / ch2 / OverflowEx.java
``` java
public class OverflowEx {

	public static void main(String[] args) {
		short sMin = -32768;
		short sMax = 32767;
		char cMin = 0;
		char cMax = 65535;
		
		System.out.println("sMin     = " + sMin);
		System.out.println("sMin - 1 = " + (short)(sMin - 1));
		System.out.println("sMax     = " + sMax);
		System.out.println("sMax + 1 = " + (short)(sMax + 1));
		System.out.println("cMin     = " + (int)cMin);
		System.out.println("cMin - 1 = " + (int)--cMin);
		System.out.println("cMax     = " + (int)cMax);
		System.out.println("cMax + 1 = " + (int)++cMax);
	}

}
```

```
sMin     = -32768
sMin - 1 = 32767
sMax     = 32767
sMax + 1 = -32768
cMin     = 0
cMin - 1 = 65535
cMax     = 65535
cMax + 1 = 0
```

`short`타입과 `char`타입의 최대값과 최소값에 1을 더하거나 뺀 결과를 출력하였다. 실행결과를 좀 더 이해하기 쉽게 정리하면 다음과 같다.

![image](https://ifh.cc/g/4mNGPt.png)

</br>

## 4.4 실수형 - float, double

### 실수형의 범위와 정밀도

실수형은 실수를 저장하기 위한 타입으로 `float`와 `double`, 두 가지가 있으며 각 타입의 변수에 저장할 수 있는 값의 범위는 아래와 같다.

![image](https://ifh.cc/g/Ctg5do.png)

표의 범위는 '양의 범위'만 적은 것으로, 이 범위에 '-'부호를 붙이면 '음의 범위'가 된다.

실수형은 소수점수도 표현해야 하므로 '얼마나 큰 값을 표현할 수 있는가'뿐만 아니라 '얼마나 0에 가깝게 표현할 수 있는가'도 중요하다.

![image](https://ifh.cc/g/o76f9T.png)

위 그림은 `int`타입과 `float`타입의 표현방식을 비교한 것인데, `int`타입은 '부호와 값', 두 부분으로 이루어져있지만, `float`타입과 같은 실수형은 '부호(S), 지수(E), 가수(M)', 세 부분ㅇ로 이루어져 있다. 즉, '2의 제곱을 곱한 형태(±M *  2<sup>E</sup>)'로 저장하기 때문에 이렇게 큰 범위의 값을 저장하는 것이 가능한 것이다.

그러나 정수형과 다릴 실수형은 오차가 발생할 수 있다는 단점이 있다. 그래서 실수형에는 표현할 수 있는 값의 범위뿐만 아니라 '정밀도(precision)'도 중요한 요소이다.

실수형 값을 저장할 때, `float`타입이 아닌 `double`타입의 변수를 사용하는 경우는 대부분 저장하려는 '값의 범위'때문이 아니라 '보다 높은 정밀도'가 필요해서이다.

> double이라는 이름은 float보다 약 2배(double)의 정밀도를 갖는다는 의미에서 붙여진 것이다.

예제 2 - 10 / ch2 / FloatEx1.java
``` java
public class FloatEx1 {

	public static void main(String[] args) {
		float f = 9.12345678901234567890f;
		float f2 = 1.2345678901234567890f;
		double d = 9.12345678901234567890d;
		
		System.out.printf("     123456789012345678901234%n");
		System.out.printf("f  : %f%n", f);	// 소수점 이하 6째자리까지 출력,
		System.out.printf("f  : %24.20f%n", f);
		System.out.printf("f2 : %24.20f%n", f2);
		System.out.printf("d  : %24.20f%n", d);
	}

}
```

```
     123456789012345678901234
f  : 9.123457	← 7자리에서 반올림되었음
f  :   9.12345695495605500000
f2 :   1.23456788063049320000
d  :   9.12345678901234600000
```

### 실수형의 저장형식

실수형은 정수형과 표현형식이 달라서, 실수형은 값을 부도소수점수(floating-point)의 형태로 저장한다. 부동소수점수는 실수를 '±M × 2<sup>E</sup>'와 같은 형태로 표현하는 것을 말하며, 부동소수점수는 부호(sign), 지수(Exponent), 가수(Mantissa), 세 부분으로 이루어져 있다.

![image](https://ifh.cc/g/s5WBgC.png)

그래서 부동소수점수는 다음과 같이 세 부분으로 나누어 저장한다.

![image](https://ifh.cc/g/pt10mv.png)

위와 같은 표현형식은 IEEE754라는 표준을 따른 것인데, IEEE754는 '전기 전자 기술자협회(IEEE, Institute of Electrical and Electronics Engineers)'에서 제정한 부동소수점수의 표현방법이다.

![image](https://ifh.cc/g/gMFnyJ.png)

1. 부호(Sign bit)

'S는 부호비트(sign bit)를 의미하며 1 bit이다. 이 값이 0이면 양수를, 1이면 음수를 의미한다. 정수형과 달리 '2의 보수법'을 사용하지 않기 때문에 양의 실수를 음의 실수로 바꾸려면 그저 부호비트만 0에서 1로 변경하면 된다.

2. 지수(Exponent)

'E'는 지수를 저장하는 부분으로 `float`의 경우, 8 bit의 저장공간을 갖는다. 지수는 '부호있는 정수'이고 8 bit로는 모두 2<sup>8</sup>(=256)개의 값을 저장할 수 있으므로, '-127 \~ 128'의 값이 저장된다. 이 중에서 -127과 128은 '숫자 아님(NaN, Not a Number)'이나 '양의 무한대(POSITIVE_INFINITY)', '음의 무한대(NEGATIVE_INFINITY)'와 같이 특별한 값의 표현을 위해 예약되어 있으므로 실제로 사용가능한 지수의 범위는 '-126 \~ 127'이다. 그래서 지수의 최대값이 127이므로 `float`타입으로 표현할 수 있는 최대값은 2<sup>127</sup>이고, 10진수로 약 10<sup>38</sup>이다. 그러나 `float`의 최소값은 가수의 마지막 자리가 2<sup>-23</sup>이므로 지수의 최소값보다 2<sup>-23</sup>배나 더 작은 값, 약 10<sup>-45</sup>이다.

3. 가수(Maintissa)

'M'은 실제 값인 가수를 저장하는 부분으로 `float`의 경우, 2진수 23자리를 저장할 수 있다. 2진수 23자리로는 약 7자리의 10진수를 저장할 수 있는데 이것이 바로 `float`의 정밀도가 된다. `double`은 가수를 저장할 수 있는 공간이 52자리로 `float`보다 약 2배이므로 `double`이 `float`보다 약 2배의 정밀도를 갖는다.

### 부동소수점의 오차

실수 중에는 '파이(π=3.141592...)'와 같은 무한소수가 존재하므로, 정수와 달리 실수를 저장할 때는 오차가 발생할 수 있다.게다가 10진수가 아닌 2진수로 저장하기 때문에 10진수로는 유한소수더라도, 2진수로 변환하면 무한소수가 되는 경우도 있다. 2진수로는 10진 소수를 정확히 표현하기 어렵기 때문이다.

2진수로 유한소수라도, 가수를 저장할 수 있는 자리수가 한정되어 있으므로 저장되지 못하고 버려지는 값들이 있으면 오차가 발생한다.

2진수로 변환된 실수를 저장할 때는 먼저 '1.xxx × 2<sup>n</sup>'의 형태로 변환하는데, 이 과정을 정규화라고 한다.

정규화된 2진 실수는 항상 '1.'으로 시작하기 때문에, '1.'을 제외한 23자리의 2진수가 가수(mantissa)로 저장되고 그 이후는 잘려나간다.

이 때 잘려나간 값들에 의해 발생할 수 있는 최고오차는 약 2<sup>-23</sup>인데, 이 값은 가수의 마지막 비트 단위와 같다. 2<sup>-23</sup>은 10진수로 0.0000001192(약 10<sup>-7</sup>)이므로 `float`의 정밀도가 7자리라고 하는 것이다.

예제 2-11 / ch2 / FloatToBinEx.java
``` java
public class FloatToBinEx {

	public static void main(String[] args) {
		float f = 9.1234567f;
		int i = Float.floatToIntBits(f);
		
		System.out.printf("%f%n", f);
		System.out.printf("%X%n", i);	// 16진수로 출력		
	}

}
```

```
9.123457
4111F9AE
```

`Float`클래스의 `floatToIntBits()`는 `float`타입의 값을 `int`타입의 값으로 해석해서 반환한다. 반환된 값을 16진수로 출력하면, `float`타입의 값이 2진수로 어떻게 저장되는지 확인할 수 있다. 실행결과를 보면, 앞서 설명한 것과 달리 0x4111F9AE이다. 그 이유는 잘려나간 첫 번째 자리의 값이 1이라서 반올림되어 0x411F9AD의 2진수 마지막 자리 두 자리의 값이 '01'에서 '10'으로 1증가 했기 때문이다.