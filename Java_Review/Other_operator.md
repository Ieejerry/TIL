Chapter 3. 연산자

# 6. 그 외의 연산자

</br>

## 6.1 조건 연산자 ? :

조건 연산자는 조건식, 식1, 식2 모두 세 개의 피연산자를 필요로 하는 삼항 연산자이며, 삼항 연산자는 조건 연산자 하나뿐이다.

![image](https://ifh.cc/g/1Om33v.png)

조건 연산자는 첫 번째 피연산자인 조건식의 평가결과에 따라 다른 결과를 반환한다. 조건식의 평가결과가 `true`이면 식1이, `false`이면 식2가 연산결과가 된다. 가독성을 높이기 위해 조건식을 괄호()로 둘러싸는 경우가 많지만 필수는 아니다.

``` java
result = (x > y) > x : y;
```

조건 연산자는 조건문인 `if`문으로 바꿔 쓸 수 있으며, `if`문 대신 조건 연산자를 사용하면 코드를 보다 간단히 할 수 있다.

![image](https://ifh.cc/g/3JDXpZ.png)

조건 연산자를 중첩해서 사용하면 셋 이상 중의 하나를 결과로 얻을 수 있다. 아래의 식은 `x`의 값이 양수면 1, 0이면 0, 음수면 -1, 즉 셋 중의 하나의 결과로 반환한다.

``` java
result = x > 0 ? 1 : (x == 0 ? 0 : -1);
```

조건 연산자를 여러 번 중첩하면 코드가 간략해지긴 하지만, 가독성이 떨어지므로 꼭 필요한 경우에 한 번 정도만 중첩하는 것이 좋다.

그리고 조건 연산자의 식1과 식2, 이 두 피연산자의 타입이 다른 경우, 이항 연산자처럼 산술 변환이 발생한다.

``` java
    x = x + (mod < 0.5 ?   0 : 0.5);    // 0과 0.5의 타입이 다르다.
→   x = x + (mod < 0.5 ? 0.0 : 0.5);    // 0이 0.0으로 변환되었다.
```

위의 식에서 조건 연산자의 피연산자 0과 0.5의 타입이 다르므로, 자동 형변환이 일어나서 `double`타입으로 통일되고 연산결과 역시 `double`타입이 된다.

예제 3-32 / ch3 / OperatorEx32.java
``` java
public class OperatorEx32 {

	public static void main(String[] args) {
		int x, y, z;
		int absX, absY, absZ;
		char signX, signY, signZ;
		
		x = 10;
		y = -5;
		z = 0;
		
		absX = x >= 0 ? x : -x;	// x의 값이 음수이면, 양수로 만든다.
		absY = y >= 0 ? y : -y;
		absZ = z >= 0 ? z : -z;
		
		signX = x > 0 ? '+' : (x == 0 ? ' ' : '-');	// 조건 연산자를 중첩
		signY = y > 0 ? '+' : (y == 0 ? ' ' : '-');
		signZ = z > 0 ? '+' : (z == 0 ? ' ' : '-');
		
		System.out.printf("x = %c%d%n", signX, absX);
		System.out.printf("y = %c%d%n", signY, absY);
		System.out.printf("z = %c%d%n", signZ, absZ);
	}

}
```

```
x = +10
y = -5
z =  0
```

</br>

## 6.2 대입 연산자 = op=

대입 연산자는 변수와 같은 저장공간에 값 또는 수식의 연산결과를 젖아하는데 사용된다. 이 연산자는 오른쪽 피연산자의 값(식이라면 평가값)을 왼쪽 피연산자에 저장한다. 그리고 저장된 값을 연산결과로 반환한다.

대입 연산자는 연산자들 중에서 가장 낮은 우선순위를 가지고 있기 때문에 식에서 제일 나중에 수행된다.

### lvalue와 rvalue

대입 연산자의  왼쪽 피연산자를 'lvalue(left value)'이라 하고, 오른쪽 피연산자를 rvalue(right value)'라고 한다.

대입 연산자의 rvalue는 변수뿐만 아니라 식이나 상수 등이 모두 가능한 반면, lvalue는 반드시 변수처럼 값을 변경할 수 있는 것이어야 한다. 그래서 리터럴이나 상수같이 값을 저장할 수 없는 것들은 lvalue가 될 수 없다.

``` java
int i = 0;
3 = i + 3;  // 에러, lvaule가 값을 젖아할 수 있는 공간이 아니다.
i + 3 = i;  // 에러, lvalue의 연산결과는 리터럴(i + 3 → 0 + 3 → 3)

final int MAX = 3;  // 변수 앞에 키워드 final을 붙이면 상수가 된다.
MAX = 10;   // 에러, 상수(MAX)에 새로운 값을 저장할 수 없다. 
```

변수 앞에 키워드 `final`을 붙이면 상수가 된다. 상수에 한 번 저장된 값은 바꿀 수 없다.

### 복합 대입 연산자

대입 연산자는 다른 연산자(op)와 결합하여 `op=`와 같은 방식으로 사용될 수 있다. 예를 들면 `i = i + 3`은 `i += 3`과 같이 표현될 수 있다. 그리고 결합된 두 연산자는 반드시 공백없이 붙여 써야 한다.

![image](https://ifh.cc/g/RozxA8.png)

왼쪽은 복합 연산자의 사용 예이고, 오른쪽은 대입 연산자를 이용한 왼쪽과 동일한 의미의 식이다.

한 가지 주의할 점은 표의 마지막 줄 처럼, 대입연산자의 우변이 둘 이상의 항으로 이루어져 있는 경우이다. `i *= 10 + j;`를 `i = i * 10 + j;`와 같은 것으로 오해하지 않아야 한다.