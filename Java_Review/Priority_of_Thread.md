Chapter 13. 쓰레드 Thread

# 5. 쓰레드의 우선순위

쓰레드는 우선순위(priority)라는 속성(멤버변수)을 가지고 있는데, 이 우선순위의 값에 따라 쓰레드가 얻는 실행시간이 달라진다. 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 서로 다르게 지정하여 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수 있다.

예를 들어 파일전송기능이 있는 메신저의 경우, 파일다운로드를 처리하는 쓰레드보다 채팅내용을 전송하는 쓰레드의 우선순위가 더 높아야 사용자가 채팅하는데 불편함이 없다. 대신 파일다운로드 작업에 걸리는 시간은 더 길어진다.

이처럼 시각적인 부분이나 사용자에게 빠르게 반응해야하는 작업을 하는 쓰레드의 우선순위는 다른 작업을 수행하는 쓰레드에 비해 높아야 한다.

</br>

### 쓰레드의 우선순위 지정하기

쓰레드의 우선순위와 관련된 메소드와 상수는 다음과 같다.

![image](https://ifh.cc/g/McN7pW.png)

쓰레드가 가질 수 있는 우선순위의 범위는 1~10이며 숫자가 높을수록 우선순위가 높다.

한 가지 더 알아두어야 할 것은 쓰레드의 우선순위는 쓰레드를 생성한 쓰레드로부터 상속받는다는 것이다. `main`메소드를 수행하는 쓰레드는 우선순위가 5이므로 `main`메소드내에서 생성하는 쓰레드의 우선순위는 자동적으로 5가 된다.

</br>

예제 13-8 / ch13 / ThreadEx8.java

``` java
public class ThreadEx8 {
	public static void main(String[] args) {
		ThreadEx8_1 th1 = new ThreadEx8_1();
		ThreadEx8_2 th2 = new ThreadEx8_2();
		
		th2.setPriority(7);
		
		System.out.println("Priority of th1(-) : " + th1.getPriority());
		System.out.println("Priority of th2(|) : " + th2.getPriority());
		
		th1.start();
		th2.start();
	}
}

class ThreadEx8_1 extends Thread {
	public void run() {
		for(int i = 0; i < 300; i++) {
			System.out.print("-");
			for(int x = 0; x < 10000000; x++);
		}
	}
}

class ThreadEx8_2 extends Thread {
	public void run() {
		for(int i = 0; i < 300; i++) {
			System.out.print("|");
			for(int x = 0; x < 10000000; x++);
		}
	}
}
```

```
Priority of th1(-) : 5
Priority of th2(|) : 7
-||-||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
```

`th1`과 `th2` 모두 `main`메소드에서 생성하였기 때문에 `main`메소드를 실행하는 쓰레드의 우선순위인 5를 상속받았다. 그 다음에 `th2.setPriority(7)`로 `th2`의 우선순위를 7로 변경한 다음에 `start()`를 호출해서 쓰레드를 실행시켰다. 이처럼 쓰레드를 실행하기 전에만 우선순위를 변경할 수 있다.

우선순위가 높아지면 한 번에 작업이 끝나버릴 수 있기 때문에 아무 일도 하지 않는 반복문을 추가하여 작업을 지연시켰다.

``` java
for(int i = 0; i < 300; i++) {
    System.out.print("|");
    for(int x = 0; x < 10000000; x++);
}
```

이전의 예제와는 달리 우선순위가 높은 `th2`의 실행시간이 `th1`에 비해 상당히 늘어난 것을 알 수 있다.

우선순위가 같은 경우 각 쓰레드에게 거의 같은 양의 실행시간이 주어지지만, 우선순위가 다르다면 우선순위가 높은 `th1`에게 상대적으로 `th2`보다 더 많은 양의 실행시간이 주어지고 결과적으로 작업 A가 B보다 더 빨리 완료될 수 있다.

멀티코어에서는 쓰레드의 우선순위에 따른 차이가 전혀 없다. 우선순위에 차등을 두어 쓰레드를 실행시키는 것이 별 효과가 없다.

멀티코어라고 해도 OS마다 다른 방식으로 스케줄링하기 때문에, 어떤 OS에서 실행하느냐에 따라 다른 결과를 얻을 수 있다. 굳이 우선순위에 차등을 두어 쓰레드를 실행하려면 특정 OS의 스케줄링 정책과 JVM의 구현을 직접 확인해봐야 한다. 자바는 쓰레드가 우선순위에 따라 어떻게 다르게 처리되어야 하는지에 대해 강제하지 않으므로 쓰레드의 우선순위와 관련된 구현이 JVM마다 다를 수 있기 때문이다.

만일 확인한다 하더라도 OS의 스케줄러에 중속적이라서 어느 정도 예측만 가능한 정도일 뿐 정확히 알 수 없다.

차라리 쓰레드에 우선순위를 부여하는 대신 작업에 우선순위를 두어 `PriorityQueue`에 저장해 놓고, 우선순위가 높은 작업이 먼저 처리되도록 하는 것이 나을 수 있다.