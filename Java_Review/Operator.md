Chapter 3. 연산자

# 1. 연산자(operator)

연산자는 '연산을 수행하는 기호'를 말한다.

</br>

## 1.1 연산자와 피연산자

연산자가 연산을 수행하려면 반드시 연산의 대상이 있어야하는데, 이것을 '피연산자(operand)'라고 한다. 피연산자로 상수, 변수 또는 식(式) 등을 사용할 수 있다.

> **연산자(operator)** : 연산을 수행하는 기호(+, -, *, /, 등)   
**피연산자(operand)** : 연산자의 작업 대상(변수, 상수, 리터럴, 수식)

다음과 같이 `x + 3`이라는 식(式)이 있을 때, `+`는 두 피연산자를 더해서 그 결과를 반환하는 덧셈 연산자이고, 변수 `x`와 상수 `3`은 이 연산자의 피연산자이다.

![image](https://ifh.cc/g/vrJgrD.png)

**연산자는 피연산자로 연산을 수행하고 나면 항상 결과값을 반환한다.**

</br>

## 1.2 식(式)과 대입연산자

연산자와 피연산자를 조합하여 계산하고자하는 바를 표현한 것을 '식(式, expression)'이라고 한다. 그리고 식을 계산하여 결과를 얻는 것을 '식을 평가(evaluation)한다.'고 한다. 하나의 식을 평가(계산)하면, 단 하나의 결과를 얻는다. 만일 `x`의 값이 `5`라면, 아래의 식을 평가한 결과는 `23`이 된다.

``` java
4 * x + 3
```

작성한 식을 프로그램에 포함시키려면, 식의 끝에 `;`를 붙여서 문장으로 만들어야 한다.

``` java
4 * x + 3;  // 문장(statement)
```

예를 들어 변수 `x`의 값이 `5`일 때, 위의 문장은 당므과 같은 과정으로 처리된다.

``` java
    4 * x + 3;
→   4 * 5 + 3;
→   23;         // 결과를 얻었지만 쓰이지 않고 사라진다.
```

식이 평가되어 `23`이라는 결과를 얻었지만, 이 값이 어디에도 쓰이지 않고 사라지기 때문에 이 문장은 아무런 의미가 없다. 그래서 아래와 같이 대입 연산자 `=`를 사용해서 변수와 같이 값을 저장할 수 있는 공간에 결과를 저장해야 한다.

``` java
    y = 4 * x + 3;
→   y = 4 * 5 + 3;
→   y = 23;         // 식의 평가결과가 변수 y에 저장된다.
```

그 다음에는 변수 `y`에 저장된 값을 다른 곳에 사용하거나 화면에 출력함으로써 의미있는 결과를 얻을 수 있다.

``` java
y = 4 * x + 3;
System.out.println(y);  // 변수 y의 값을 화면에 출력
```

만일 식의 평가결과를 출력하기만 원할 뿐, 이 값을 다른 곳에 사용하지 않을 것이라면 다음과 같이 변수에 저장하지 않고 `println()`메소드의 괄호()안에 직접 식을 써도 된다.

``` java
    System.out.println(4 * x + 3);
→   System.out.println(23);     // 23이 화면에 출력된다.
```

</br>

## 1.3 연산자의 종류

![image](https://ifh.cc/g/MVMpqf.png)

크게 산술, 비교, 논리, 대입 4가지로 나눌 수 있다.

### 피연산자의 개수에 의한 분류

피연산자의 개수로 연산자를 분류하기도 하는데, 피연산자의 개수가 하나면 '단항 연산자', 두 개면 '이항 연산자', 세 개면 '삼항 연산자'라고 부른다. 대부분의 연산자는 '이항 연산자'이고, 삼항 연산자는 오직 `?:` 하나뿐이다.

![image](https://ifh.cc/g/thQmWz.png)

위의 식에는 두 개의 연산자가 포함되어 있는데, 둘 다 같은 기호 `-`로 나타내지만 엄연히 다른 연산자이다. 왼쪽의 것은 '부호 연산자'이고, 오른쪽의 것은 '뺄셈 연산자'이다. 이처럼 서로 다른 연산자의 기호가 같은 경우도 있는데, 이럴 때는 피연산자의 개수로 구분이 가능하다.

![image](https://ifh.cc/g/wnC7wn.png)

'부호 연산자'는 단항 연산자로 피연산자가 `3` 한 개뿐이지만, '뺄샘 연산자'는 이항 연산자로 피연산자가 `-3`과 `5` 두 개이다.

이처럼 연산자를 기능별, 피연산자의 개수별로 나누어 분류하는 것은 **'연산자의 우선순위'** 때문이다.

</br>

## 1.4 연산자의 우선순위과 결합규칙

식에 사용된 연산자가 둘 이상인 경우, 연산자의 우선순위에 의해서 연산순서가 결정된다.

![image](https://ifh.cc/g/g6g55A.png)

실제 프로그래밍에서 사용되는 대부분의 식은 이처럼 상식적으로 판단이 가능한 수준이다.

상식만으로 판단하기 쉽지 않은 우선순위 몇 가지를 아래의 표에 정리하였다.

![image](https://ifh.cc/g/83L92O.png)

만일 우선순위가 확실하지 않는다면, 먼저 계산되어야하는 부분을 괄호로 묶어주면 된다. 괄호 안의 계산식이 먼저 계산될 것이 확실하기 때문이다.

> 괄호는 연산자가 아니다. 연산자의 우선순위를 임의로 저장할 때 사용하는 기호일 뿐이다.

### 연산자의 결합규칙

우선순위가 같다고 해서 아무거나 먼저 처리하는 것이 아니고 나름대로의 규칙을 가지고 있는데, 그 규칙을 **'연산자의 결합규칙'**이라고 한다.

연산자의 결합규칙은 연산자마다 다르지만, 대부분 왼쪽에서 오른쪽의 순서로 연산을 수행하고, 단항 연산자와 대입 연산자만 그 반대로, 오른쪽에서 왼쪽의 순서로, 연산을 수행한다.

대입 연산자는 우변의 값을 좌변에 저장하고, 저장된 값을 연산결과로 반환한다.

연산자의 우선순위에 대해서 정리하면 다음과 같다.

> 1. **산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.**
> 2. **단항(1) > 이항(2) > 삼항(3). 단항 연산자의 우선순위가 이항 연산자보다 높다.**
> 3. **단항 연산자와 대입 연산자를 제외한 모든 연산의 진행방향은 왼쪽에서 오른쪽이다.**

![image](https://ifh.cc/g/tHhQDO.png)

> 단항 연산자에 있는 '+'와 '-'는 부호연산자이고, '(type)'은 형변환 연산자이다.

> instanceof는 객체의 타입을 확인하는데 사용되는 연산자이다.

</br>

## 1.5 산술 변환(usual arithetic conversion)

이항 연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 피연산자의 타입이 서로 다르다면 연산 전에 형변환 연산자로 타입을 일치시켜야 한다. 예를 들어 `int`타입과 `float`타입을 덧셈하는 경우, 형변환 연산자를 사용해서 피연산자의 타입을 둘 다 `int` 또는 `float`로 일치시켜야 한다.

``` java
int i = 10;
float f = 20.0f;

float result = f + (float)i;    // 형변환으로 두 피연산자의 타입을 일치
```

대부분의 경우, 두 피연산자의 타입 중에서 더 큰 타입으로 일치시키는데, 그 이유는 작은 타입으로 형변환하면 원래의 값이 손실될 가능성이 있기 때문이다. 앞서 배운 것과 같이 작은 타입에서 큰 타입으로 형변환하는 경우, 자동적으로 형변환되므로 형변환 연산자를 생략할 수 있다.

``` java
float result = f + i;   // 큰 타입으로 형변환시, 형변환연산자 생략가능
```

연산 전에 피연산자 타입의 일치를 위해 자동 형변환되는 것을 '산술 변환' 또는 '일반 산술 변환'이라 하며, 이 변환은 이항 연산에서만 아니라 단항 연산에서도 일어난다. '산술 변환'의 규칙은 다음과 같다.

1. **두 피연산자의 타입을 같게 일치시킨다.(보다 큰 타입으로 일치)**   
**long + int → long + long → long**   
**flot + int → float float → float**   
**double + float → double + double → double**
2. **피연산자의 타입이 int보다 작은 타입이면 int로 변환한다.**   
**byte + short → int + int → int**   
**char + short → int + int → int**

> 모든 연산에서 '산술 변환'이 일어나지만, 쉬프트 연산자(<<, >>), 증감연산자(++, --)는 예외이다.

첫 번째 규칙은 피연산자의 값손실을 최소화하기 위한 것이고, 두 번째 규칙은 정수형의 기본 타입인 `int`가 가장 효율적으로 처리할 수 있는 타입이기 때문에, 그리고 `int`보다 작은 타입, 예를 들면 `char`나 `short`의 표현범위가 좁아서 연산중에 오버플로우(overflow)가 발생할 가능성이 높기 때문에 만들어진 것이다.

연산결과의 타입은 피연산자의 타입과 일치한다. 예를 들어 `int`와 `int`의 나눗셈 연산결과는 `int`이다. `float`과 `double`과 같은 실수형이 아니기 때문에 소수점 이하는 버려진다. 그래서 아래의 식 '5 나누기 2'의 결과가 2.5가 아닌 2이다.

int / int → int   
5 / 2 → **2**

위의 식에서 2.5라는 실수를 결과로 얻으려면, 피연산자 중 어느 한 쪽을 `float`와 같은 실수형으로 형변환해야 한다. 그러면, 다른 한 쪽은 산술 변환의 첫 번째 규칙에 의해 자동적으로 형변환되어 두 피연산자 모두 실수형이 되고, 연산결과 역시 실수형의 값을 얻을 수 있다.

**int /** (float)**int** → int  / float → **float / float** → **float**   
5 / **(float)2** → 5 / 2.0f → 5.0f / 2.0f → 2.5f

결국 산술 변환이란, 연산 직전에 발생하는 자동 형변환이다.

아래의 두 가지 규칙만 잘 기억하면 된다.

> **산술 변환이란? 연산 수행 직전에 발생하는 피연산자의 자동 형변환**   
> 1. 두 피연산자의 타입을 같게 일치시킨다(보다 큰 타입으로 일치).
> 2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환된다.