Chapter 2. 변수

# 형변환

</br>

## 5.1 형변환(캐스팅, casting)이란?

변수나 리터럴의 타입을 다른 타입으로 변환하는 것을 '형변환(casting)'이라고 한다.

> **형변환이란, 변수 또는 상수의 타입을 다른 타입으로 변환하는 것**

</br>

## 5.2 형변환 방법

형변환하고자 하는 변수나 리터럴의 앞에 변환하고자 하는 타입을 괄호와 함께 붙여주기만 하면 된다.

> **(타입)피연산자**

여기에 사용되는 괄호()는 '캐스트 연산자' 또는 '형변환 연산자'라고 하며, 형변환을 '캐스팅(casting)'이라고 한다.

예를 들어 다음과 같은 코드가 있을 때,

```java
double d = 85.4;
int score = (int)d; // double타입의 변수 d를 int타입으로 형변환
```

두 번째 줄의 연산과정을 단계별로 살펴보면 다음과 같다.

``` java
    int score = (int)d;
=>  int score = (int)85.4;  // 변수 d의 값을 읽어 와서 형변환한다.
=> int score = 85;          // 형변환의 결과인 85를 변수 score에 저장한다.
```

형변환 연산자는 그저 피연산자의 값을 읽어서 지정된 타입으로 형변환하고 그 결과를 반환할 뿐이다. 그래서 **피연산자인 변수 `d`의 값은 형변환 후에도 아무런 변화가 없다.**

예제 2-12 / ch2 / CastingEx1.java
``` java
public class CastingEx1 {

	public static void main(String[] args) {
		double d = 85.4;
		int score = (int)d;
		
		System.out.println("score = " + score);
		System.out.println("d = " + d);
	}

}
```

```
score = 85
d = 85.4    ← 형변환 후에도 피연산자에는 아무런 변화가 없다.
```

기본형(primitive type)에서 `boolean`을 제외한 나머지 타입들은 서로 형변환이 가능하다. 그리고 기본형과 참조형간의 형변환은 불가능하다.

![image](https://ifh.cc/g/xsKxBP.png)

`float`타입의 값을 `int`타입으로 변환할 때 소수점 이하의 값은 반올림 아닌 버림으로 처리된다.

</br>

## 5.3 정수형간의 형변환

큰 타입에서 작은 타입으로의 변환, 예를 들어서 `int`타입(4 byte)의 값을 `byte`타입(1 byte)으로 변환하는 경우는 아래와 같이 크기의 차이만큼 잘려나간다. 그래서 경우에 따라 '값손실(loss of data)'이 발생할 수 있다.

![image](https://ifh.cc/g/8tFDmC.png)

반대로 작은 타입에서 큰 타입으로의 변환, 예를 들어서 `byte`타입(1 byte)의 값을 `int`타입(4 byte)으로 변환하는 경우는 저장공간의 부족으로 잘려나가는 일이 없으므로 값 손실이 발생하지 않는다. 그리고 나머지 빈공간은 0 또는 1로 채워진다.

![image](https://ifh.cc/g/8KGm45.png)

원래 값을 채우고 남은 빈공간은 0으로 채우는 게 보통이지만, 변환하려는 값이 음수인 경우에는 빈 공간을 1로 채운다. 그 이유는 형변환 후에도 부호를 유지할 수 있도록 하기 위해서이다.

![image](https://ifh.cc/g/Rmx7zO.png)

예제 2-13 / ch2 / CastingEx2.java
``` java
public class CastingEx2 {

	public static void main(String[] args) {
		int i = 10;
		byte b = (byte)i;
		System.out.printf("[int -> byte] i = %d -> b = %d%n", i, b);
		
		i = 300;
		b = (byte)i;
		System.out.printf("[int -> byte] i = %d -> b = %d%n", i, b);
		
		b = 10;
		i = (int)b;
		System.out.printf("[byte -> int] b = %d -> i = %d%n", b, i);
		
		b = -2;
		i = (int)b;
		System.out.printf("[byte -> int] b = %d -> i = %d%n", b, i);

		System.out.println("i = " + Integer.toBinaryString(i));
	}

}
```

```
[int -> byte] i = 10 -> b = 10
[int -> byte] i = 300 -> b = 44
[byte -> int] b = 10 -> i = 10
[byte -> int] b = -2 -> i = -2
i = 11111111111111111111111111111110
```

예제의 마지막에는 변수 i의 값인 -2가 2진수로 출력된 것이다. 이처럼 `Integer.toBinaryString(int i)`라는 메소드를 이용하면, 10진 정수를 2진 정수로 변환한 문자열을 얻을 수 있다.

</br>

## 5.4 실수형 간의 형변환

실수형에서도 정수형처럼 작은 타입에서 큰 타입으로 변환하는 경우, 빈 공간을 0으로 채운다. `float`타입의 값을 `double`타입으로 변환하는 경우, 지수(E)는 `float`의 기저인 127을 뺀 후 `double`의 기저인 1023을 더해서 변환하고, 가수(M)은 `float`의 가수 23자리를 채우고 남은 자리를 0으로 채운다.

반대로 `double`타입에서 `float`타입으로 변환하는 경우, 지수(E)는 `double`의 기저인 1023을 뺀 후 `float`의 기저인 127을 더하고 가수(M)은 `double`의 가수 52자리 중 23자리만 저장되고 나머지는 버려진다.

한 가지 주의할 점은 형변환할 때, 가수의 24번째 자리에서 반올림이 발생할 수 있다는 것이다. 24번째 자리의 값이 1이면, 반올림이 발생하여 23번째 자리의 값이 1 증가한다.

그리고 `float`타입의 범위를 넘는 값을 `float`로 형변환하는 경우는 '±무한대' 또는 '±0'을 결과로 얻는다.

``` java
double d = 1.0e100; // float의 최대값보다 큰 값을 d에 저장(1.0×10^100)
float f = (float)d; // d의 값을 float로 형변환해서 f에 저장. f는 무한대가 된다.

double d = 1.00e-50;    // float의 최소값보다 작은 값을 d에 저장(1.0×10^-50)
float f = (float)d; // f의 값은 0이 된다.
```

예제 2-14 / ch2 / CastingEx3.java
``` java
public class CastingEx3 {

	public static void main(String[] args) {
		float f = 0.1234567f;
		double d = 0.1234567;
		double d2 = (double)f;
		
		System.out.printf("f = %20.18f%n", f);
		System.out.printf("d = %20.18f%n", d);
		System.out.printf("d2= %20.18f%n", d2);
	}

}
```

```
f = 0.123456701636314390
d = 0.123456700000000000
d2= 0.123456701636314390
```

변수 `f`와 `d`에 같은 값을 저장했지만, 실제로 저장된 값은 다르다. 변수 `f`에 저장된 값을 `double`타입으로 형변환해도 값은 그대로이다.

같은 값을 저장해도 `float`와 `double`의 정밀도 차이 때문에 서로 다른 값이 저장된다.

저장할 때 이미 값이 달라졌기 때문에, 형변환을 해도 값이 같아지지 않는다.

</br>

## 5.5 정수형과 실수형 간의 형변환

### 정수형을 실수형으로 변환

정수를 2진수로 변환한 다음에 정규화해서 실수의 저장형식에 맞게 저장한다. 한 가지 주의할 점은 실수형의 정밀도의 제한으로 인한 오차가 발생할 수 있다.

![image](https://ifh.cc/g/lmQHZB.png)

위의 그림은 8자리의 `int`값을 각각 `float`와 `double`로 변환한 다음에 다시 `int`로 형변환했을 때 값의 변화를 보여준다. `float`는 정밀도가 약 7자리이므로 8자리의 정수를 저장할 때 오차가 발생하는 것을 알 수 있다. 반면에 `double`은 약 15자리의 정밀도를 갖기 때문에 오차없이 변환이 가능하다.

### 실수형을 정수형으로 변환

실수형을 정수형으로 변환하면, 실수형의 소수점이하 값은 버려진다. 정수형의 표현형식으로 소수점 이하의 값은 표현할 수 없기 때문이다.

그래서 실수형을 정수형으로 형변환할 때 반올림이 발생하지 않는다.

만일 실수의 소수점을 버리고 남은 정수가 정수형의 저장범위를 넘는 경우에는 정수의 오버플로우가 발생한 결과를 얻는다.

예제 2-15 / ch2 / CastingEx4.java
``` java
public class CastingEx4 {

	public static void main(String[] args) {
		int i = 91234567;	// 8자리의 10진수
		float f = (float)i;	// int를 float로 형변환
		int i2 = (int)f;	// float를 다시 int로 형변환
		
		double d = (double)i;	// int를 double로 형변환
		int i3 = (int)d;	// double을 다시 int로 형변환
		
		float f2 = 1.666f;
		int i4 = (int)f2;
		
		System.out.printf("i = %d%n", i);
		System.out.printf("f = %f i2 = %d%n", f, i2);
		System.out.printf("d = %f i3 = %d%n", d, i3);
		System.out.printf("(int)%f = %d%n", f2, i4);
	}

}
```

```
i = 91234567
f = 91234568.000000 i2 = 91234568
d = 91234567.000000 i3 = 91234567
(int)1.666000 = 1
```

</br>

## 5.6 자동 형변환

서로 다른 타입간의 대입이나 연산을 할 때, 형변환으로 타입을 일치시키는 것이 원칙이다. 하지만, 경우에 따라 편의상의 이유로 형변환을 생략할 수 있다. 그렇다고 해서 형변환이 이루어지지 않는 것은 아니고, 컴파일러가 생략된 형변환을 자동적으로 추가한다.

``` java
float f = 1234; // 형변환의 생략. float f = (float)1234;와 같음
```

위의 문장에서 우변은 `int`타입의 상수이고, 이 값을 저장하려는 변수의 타입은 `float`이다. 서로 타입이 달라서 형변환이 필요하지만 편의상 생략하였다. `float`타입의 변수는 1234라는 값을 저장하는데 아무런 문제가 없기 때문이다.

그러나 다음과 같이 변수가 저장할 수 있는 값의 범위보다 더 큰 값을 저장하려는 경우에 형변환을 생락하면 에러가 발생한다.

``` java
byte b = 1000;  // 에러. byte의 범위(-128 ~ 127)를 넘는 값을 저장
```

에러 메세지는 'incompatible types: possible lossy conversion from int to byte'인데, 앞서 배운 것과 같이 큰 타입에서 작은 타입으로의 형변환은 값 손실이 발생할 수 있다는 뜻이다.

그러나 다음과 같이 명시적으로 형변환 해줬을 경우, 형변환이 프로그래머의 실수가 아닌 의도적인 것으로 간주하고 컴파일러는 에러를 발생시키지 않는다.

``` java
char ch = (char)1000;   // 명시적 형변환. 에러가 발생하지 않는다.
```

또 다른 예로 다음과 같은 계산식에서 자주 형변환이 생략되는데, 서로 다른 두 타입의 연산에서는 먼저 타입을 일치시킨 다음에 연산을 수행해야 함로, 연산과정에서 형변환이 자동적으로 이루어진다.

``` java
int i = 3;
double d = 1.0 + i; // double d = 1.0 + (double)i; 에서 형변환이 생략됨
```

서로 다른 두 타입가의 덧셈에서는 두 타입 중 표현범위가 더 넓은 타입으로 형변환하여 타입을 일치시킨 다음에 연산을 수행한다. 그렇게 하는 것이 값 손실의 위험이 더 적어서 올바른 결과를 얻을 확률이 높기 때문이다.

``` java
    double d = 1.0 + i;
→   double d = 1.0 + (double)i;
→   double d = 1.0 + (double)3; // 3을 double타입으로 형변환하면 3.0이 된다.
→   double d = 1.0 + 3.0;       // double과 double의 덧셈결과 타입은 double.
→   double d = 4.0;             // double + double = double
```

이처럼 연산과정에서 자동적으로 발생하는 형변환을 '산술 변환'이라고 한다.

### 자동 형변환의 규칙

> **기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환한다.**

표현범위가 좁은 타입에서 넓은 타입으로 형변환하는 경우에는 값 손실이 없으므로 두 타입 중에서 표현범위가 더 넓으 쪽으로 형변환된다.

![image](https://ifh.cc/g/dcOpng.png)

형변환이 가능한 7개의 기본형을 왼쪽부터 표현할 수 있는 값의 범위가 작은 것부터 큰 것의 순서로 나열할 것이다.

화살표방향으로의 변환, 즉 왼쪽에서 오른쪽으로의 변환은 형변환 연산자를 사용하지 않아도 자동 형변환이 되며, 그 반대 방향으로의 변환은 반드시 형변환 연산자를 써줘야한다.

보통 자료형의 크기가 큰 것일수록 값의 표현범위가 크기 마련이지만, 실수형은 정수형과 값을 표현하는 방식이 다르기 때문에 같은 크기일지라도 실수형이 정수형보다 훨씬 더 큰 표현 범위를 갖기 때문에 `float`와 `double`이 같은 크기인 `int`와 `long`보다 오른쪽에 위치한다.

> 정수형을 실수형으로 형변환하는 경우, 정밀도의 한계로 오차가 발생할 수 있다.

`char`와 `short`은 둘 다 2 byte의 크기로 크기가 같지만, `char`의 범위는 '0 \~ 2<sup>16</sup> - 10(0 \~ 65535)'이고 `short`의 범위는 '-2<sup>15<sup> \~ 2<sup>15</sup> - 1(-32768 \~ 32767)'이므로 서로 범위가 달라서 둘 중 어느 쪽으로의 형변환도 값 손실이 발생할 수 있으므로 자동 형변환이 수행될 수 없다.

> 1. **boolean을 제외한 나머지 7개의 기본형은 서로 형변환이 가능하다.**
> 2. **기본형과 참조형은 서로 형변환할 수 없다.**
> 3. **서로 다른 타입의 변수간의 연산은 형변환을 하는 것이 원칙이지만, 값의 범위가 작은 타입에서 큰 타입으로의 형변환은 생략할 수 있다.**