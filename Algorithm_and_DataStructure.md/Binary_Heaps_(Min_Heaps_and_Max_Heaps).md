# Binary Heaps (Min-Heaps and Max-Heaps)

</br>

## Heap이란?

</br>

[![2023-04-22-6-34-13.png](https://i.postimg.cc/8kvCGRHx/2023-04-22-6-34-13.png)](https://postimg.cc/8s1GBrxb)

</br>

최댓값이나 최솟값을 찾아내는 연산을 빠르게 하기 위해 고안된 완전 이진 트리를 기본으로 한 자료구조이다. Heap에는 최소 Heap, 최대 Heap 두 가지가 있다.

최소 Heap에는 작은 값을 항상 위에 노드에 있게 해서 트리의 루트에는 가장 작은 값이 오도록 하는 것이 최소 Heap이다.

반대로 최대 Heap은 가장 큰 값이 맨 위에 오도록 모든 노드들은 자기 부모 노드에 자기보다 큰 값을 가지는 트리 구조이다.

근본적으로 두 Heap의 원리는 같아서 최소 Heap만 알면 최대 Heap은 숫자만 반대로 되어 있다고 생각하면 된다.

</br>

## 최소 Heap에 노드 삽입하기

</br>

[![2023-04-22-6-42-16.png](https://i.postimg.cc/L8J9yjny/2023-04-22-6-42-16.png)](https://postimg.cc/cvNGCg7Y)

</br>

최소 Heap에 노드를 삽입할 때는 우선 완전 트리 맨 끝에 노드를 추가하는데, 트리가 완전 이진 트리 형태를 읽지 않도록 마지막 레벨에 왼쪽부터 채워넣어야 한다. 추가한 직후에는 데이터가 트리 안에서 정렬이 되어 있지 않은 상태이다. 그래서 다음으로 자신의 부모노드와 비교해서 자기가 값이 작으면 부모 노드랑 자리를 바꾼다. 그래서 거기서 또 부모 노드와 비교를 해서 부모 노드의 값이 자기의 값보다 작거나, 루트에 도착할 때까지 반복한다.

이 작업은 밸런스가 맞춰져있는 완전 이진 트리에서 이루어지기 때문에 한 레벨씩 루트까지 올라간다면 한 번 돌 때마다 절반씩 맞춰 떨어지니깐 O(log n)의 시간 복잡도를 갖는다.

</br>

## 최소 Heap에 노드 꺼내오기

</br>

[![2023-04-22-6-45-24.png](https://i.postimg.cc/vmpt176C/2023-04-22-6-45-24.png)](https://postimg.cc/f3f9p9Cv)

</br>

최소 Heap에 노드를 요청할 때는 가장 작은 값을 요청한다. 최소 Heap에서 가장 작은 값은 루트에 있기 때문에 값을 가져오는 것은 어렵지 않다.

</br>

[![2023-04-22-6-47-15.png](https://i.postimg.cc/YqngGN58/2023-04-22-6-47-15.png)](https://postimg.cc/svW1bWDZ)

</br>

그러나 루트의 값을 꺼낸 다음에 루트의 자리가 비어버리기 때문에 루트를 채워줘야 한다.

</br>

[![2023-04-22-6-48-43.png](https://i.postimg.cc/5Nh4R6Lb/2023-04-22-6-48-43.png)](https://postimg.cc/kByPVMTp)

</br>

그래서 루트를 꺼낸 후에 완전 이진 트리의 맨 마지막 노드를 루트에 채운다. 이렇게 하면 노드는 정렬이 안되어 있다. 그래서 다음으로 자신의 자식 노드들과 비교하여 자기보다 작은 노드와 자리를 바꾼다. 자식이 두 개인 경우 두 개 다 비교를 해서 둘 중 더 작은 노드와 자리를 바꾼다.

</br>

[![2023-04-22-6-51-59.png](https://i.postimg.cc/ZYDp0xtH/2023-04-22-6-51-59.png)](https://postimg.cc/pyzp68d5)

</br>

2와 4중 2가 더 작기 때문에 2가 루트로 올라가고, 6은 아래로 내려온다. 6은 아래의 5보다 크기 때문에 5와 6의 자리를 바꾼다.

</br>

[![2023-04-22-6-53-53.png](https://i.postimg.cc/cLJJ3VR8/2023-04-22-6-53-53.png)](https://postimg.cc/ZC1ZtsDT)

</br>

이렇게 내려가다가 자식이 둘 다 자기보다 크거나, 맨 마지막 잎사귀에 도달하게 되면 거기서 멈추게 된다.

이 작업은 루트에서 한 레벨씩 내려가다가 맨 마지막 레벨까지 내려올 수 있기 때문에 최대 O(log n)의 시간복잡도를 갖는다.