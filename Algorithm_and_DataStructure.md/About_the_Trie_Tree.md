# Trie(트라이) Tree에 대해서

</br>

## Tries

</br>

[![2023-04-24-7-12-17.png](https://i.postimg.cc/W1FMFLf9/2023-04-24-7-12-17.png)](https://postimg.cc/87GF93GW)

</br>

트라이는 특별히 문자열에서 검색을 빠르게 해주는 트리 구조이다. 예를 들어 정수형 자료에 대해서 이진 트리로 검색을 하면 O(log n)의 시간이 걸리는데, 그런데 여기서 문자열을 검색을 하면, 

</br>

[![2023-04-24-7-14-55.png](https://i.postimg.cc/4yy1WKBG/2023-04-24-7-14-55.png)](https://postimg.cc/bSXbJw7V)

</br>

그냥 노드에 들어가서 검색할 수 있는 것이 아니라, 노드를 매번 방문할 떄마다 문자열 하나하나를 다 비교를 해야 한다. 그래서 문자열을 검색하는 경우에는 문자열의 최대 길이가 M이라고 했을 때, O(M log n)의 시간이 걸린다.

이 문제를 해결하기 위해서 Trie(트라이)라는 트리를 이용하는데, 

</br>

[![2023-04-24-7-17-54.png](https://i.postimg.cc/MTK48pdP/2023-04-24-7-17-54.png)](https://postimg.cc/mcJVYBxC)

</br>

얘를 들어서, 사전을 만든다고 생각을 하고, 한 글자에 레벨을 하나씩 가도록 한다. 문자열을 한 자씩 다음 문자는 자식 노드에서 찾는다. 트리의 문자열이 세로로 저장이 되어 있는 것이다. 문자열이 죄다 똑같은 문자로 시작하는 것이 아니니깐 root 노드는 비워주고, 그 다음부터 car라는 단어를 찾을 때, 마지막 노드 r에 car에 대한 정보가 들어 있고, cat을 찾고 싶으면 t에 cat에 정보가 들어있다. 경찰(cap)의 정보를 찾고 싶으면 p에 cop의 정보가 있고, 찾는 정보가 copy이면, 노드 y까지 내려와서 노드 y에서 copy라는 정보를 얻을 수 있다.

그리고 모든 노드는 하나가 최대 26개의 알파벳 노드를 가질 수 있다. 대문자와 특수문자를 포함한다면 훨씬 더 많은 노드를 가질 수 있는데, 이런 식으로 검색을 하게 되면 M이 문자열의 최대 길이라고 할 때, O(M)의 시간만 걸리는 문자열 검색 구조를 만들 수 있다.