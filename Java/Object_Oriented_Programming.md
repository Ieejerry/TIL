b# 객체 지향 프로그래밍

## 객체 지향 프로그래밍
객체지향 프로그래밍(Object-Oriented Programming) 줄여서 OOP는 좀 더 나은 프로그램을 만들기 위한 프로그래밍 패러다임으로 추상적이고 어렵게 이야기하면 로직을 상태(state)와 행위(behave)로 이루어진 객체로 만드는 것이다. 즉, 서로 연관 되어있는 상태(state)와 행위(behave)를 그룹핑(카테고라이징) 해놓은 일종의 객체라고 할 수 있다. 이 객체들을 마치 레고 블럭처럼 조립해서 하나의 완제품이라고 하는 소프트웨어(프로그램)를 만드는 것(프로그래밍 기법)이 객체지향 프로그래밍이라고 할 수 있다. 다시 말해서 객체지향 프로그래밍은 객체를 만드는 것이고, 따라서 객체지향 프로그래밍의 시작은 객체란 무엇인가를 이해하는 것이라고 할 수 있다.

> 객체지향 프로그래밍에 대해 공부할 때에는 철학적으로 다가가기 보다는 객체지향 프로그래밍에 대한 문법적인 쓰임, 문법적인 형식, 또 객체를 어떻게 만들고, 객체를 어떻게 사용해야되는지 집중해서 공부해야한다.

객체지향 프로그래밍이란 객체를 만드는 것이고, 매우 구체적이고 문법적인 기능이 언어 차원에서 제공되는 것이다.
어떠한 취지(기능)와 연관되어 있는 로직(여러가지 변수와 메소드)을 객체라는 것으로 그룹핑한 것이다. 그리고 객체라는 그룹으로 연관성이 없는 로직과 분류, 구분해주는 역할을 해준다.

> 로직 = 변수, 메소드

객체의 **핵심**은 
1. 특정 기능을 위한 변수들과 메소드들을 그룹핑한 것이다.
2. 그룹핑한 그룹으로 다른 연관성이나 성격이 다른 로직들을 구분 및 분류를 해준다.

> 하나의 프로그램은 하나의 취지(기능)를 가진 로직으로 이루어진 것이 아니라, 여러 개의 목적성을 가지고 있는 로직들의 집합이다.

이런 객체들을 다른 로직에 적용하다보면 여러가지 문제가 발생하게 된다.
그러한 문제들을 완화하기 위해 여러가지 로직을 제한 및 컨트롤하는 여러가지 기능들이 추가되었다.

</br>

## 문법과 설계
객체지향 프로그래밍 교육은 크게 두 가지로 구분된다.

### 문법
첫번째는 객체지향을 편하게 할 수 있도록 언어가 제공하는 기능을 익히는 것이다. 이러한 기능들은 if, for문처럼 문법적인 구성을 가지고 있다. 이 문법을 이해하고, 숙지해야 객체를 만들 수 있다. 객체를 만드는 법에 대한 학습이라고 할 수 있다.

### 설계
두번째는 좋은 객체를 만드는 법이다. 이것을 다른 말로는 설계를 잘하는 법이라고 할 수 있다. 좋은 설계는 현실을 잘 반영해야 되는데 현실은 복잡하다. 하지만 그 복잡함 전체가 필요한 것은 아니다.

> 설계라는 것은 현실에서 관심있는 어떠한 특성 또는 어떤 관점을 소프트웨어화 시켜서 문제를 해결하는 프로그램 혹은 프로그래밍이라고 할 수 있다.

![image](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1854.gif)

위의 그림은 런던의 지도다. 지하철을 이용한다면 사람들은 오른쪽 하단의 지도를 선호할 것이다. 왼쪽 상단의 지도는 현실의 복잡함을 나타낸다. 오른쪽 하단의 지도는 지하철 탑승자의 관심사만을 반영하고 있다. 역 간의 거리나 실제 위치와 같은 요소들은 모두 배제하고 있다. 이렇게 복잡함 속에서 필요한 관점만을 추출하는 행위를 **추상화**라고 한다.

지하철 노선도가 디자인의 추상화라고 한다면 프로그램을 만든다는 것은 소프트웨어의 추상화라고 할 수 있다. 객체 지향 프로그래밍은 좀 더 현실을 잘 반영하기 위한 노력의 산물이다. 이것은 단순히 객체 지향의 문법을 이용해서 객체를 만든다고 달성되는 것이 아니다. 고도의 추상화 능력이 필요하다. 좋은 설계는 문법을 배우는 것보다 훨씬 어려운 일이다. 심지어 이것은 지식을 넘어서 지혜의 영역이다. 좋은 설계를 위한 조언들은 많지만 이러한 조언들은 조언자의 입을 떠나는 순간 생명력을 잃어버린다. 지식은 전수되지만 지혜는 전수되지 않기 때문이다. 스스로 경험하고 깨우쳐서 자기화시켜야 한다.

객체지향의 설계 원칙이나 객체 지향의 철학적인 의미는 대단히 중요하다. 하지만 이러한 것들을 처음부터 이해하고 공부하려고 한다면 매우 어렵다. 그래서 일단은 지식부터 익혀야 한다고 생각한다. 언어가 지원하는 객체지향 문법을 배우고, 이것들이 어떻게 동작하는지를 충분히 이해한 다음에 비로소 설계 원칙도 이야기할 수 있고, 객체와 사물의 비유도 시도해 볼 수 있고, 지혜라고 하는 것을 스스로 추구할 수 상태가 될 수 있을 것이다. 몇 가지 객체지향이 추구하는 지향점을 알아본 다음에 구체적인 문법을 알아보겠다.

</br>

## 부품화
프로그래밍은 정신적인 활동이다. 정신적인 것은 실체가 없고, 무한하고, 유연하다. 이러한 특성은 정신이 가진 장점이면서  소프트웨어의 극치다. 하지만 정신의 이러한 특성은 때로 오해나 모순 같은 문제점을 유발한다. 소프트웨어도 이러한 문제점을 그대로 상속받는다. 이러한 문제점을 극복하기 위한 노력 중의 하나가 부품화라고 할 수 있다. 객체 지향과 부품화를 동일시 할 수는 없지만 부품화라고 하는 소프트웨어의 큰 흐름은 객체 지향이 만들어지는데 지대한 공헌을 했다고 할 수 있다. 하드웨어에서 이루어지는 부품화의 예를 들어보자면

아래의 컴퓨터는 초창기의 컴퓨터다.

![image](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1857.gif)

본체와 모니터와 키보드가 하나로 단일화되어 있다. 이것의 문제점은 분명하다. 모니터가 고장 나면 컴퓨터를 바꿔야 한다. 키보드가 고장 나도 컴퓨터를 교체해야 한다.

![image](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1856.gif)

그래서 위와 같이 모니터와 본체와 컴퓨터를 분리했다. 다시 말해서 부품화 시킨 것이다. 기능들을 부품화 시킨 덕분에 소비자들은 더 좋은 키보드나 저렴한 모니터를 선택할 수 있게 되었다. 또 문제가 생겼을 때 그 문제가 어디에서 발생한 것인지 파악하고 해결하기가 훨씬 쉬워진다.

위의 그림에서 모니터와 키보드 그리고 본체를 분리하는 기준을 세우는 것이 추상화일 것이다. 위 제품의 기획자는 컴퓨터를 입력과 출력 그리고 연산 & 저장으로 분류하고 있다. 이 분류에 따라서 부품들을 모으고 분리해서 모니터, 키보드, 본체와 마우스라는 개별적인 완제품을 만들고 있다. 이 완제품들을 부품으로 조합하면 컴퓨터라는 하나의 완제품이 만들어진다.

아래 컴퓨터는 저장 장치를 부품화시키고 있다.

![image](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1858.gif)

또 아래 장치는 최신 데스크탑이다. 그런데 부품화를 제거하고 있다. 기술이 경량화되면서 컴퓨터는 더욱 작아지게 되었고, 그 결과 컴퓨터를 부품화하는 것의 매력이 반감되고 있기 때문에 라는 생각을 해볼 수 있다. 부품화가 중요한 것임에는 분명하지만 그 보다 중요한 것은 자신이 처해 있는 환경, 자신이 하고자 하는 것의 **적합함**이라고 생각한다. 그래서 설계라는 것(프로그래밍)은 고정된 방법이 없고, 정답도 없다.

![image](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1859.gif)

객체 지향은 부품화의 정점이라고 할 수 있다. 메소드는 부품화의 예라고 할 수 있다. 메소드를 사용하는 기본 취지는 연관되어 있는 로직들을 결합해서 메소드라는 완제품을 만드는 것이다. 그리고 이 메소드들을 부품으로 해서 하나의 완제품인 독립된 프로그램을 만드는 것이다. 메소드를 사용하면 코드의 양을 극적으로 줄일 수 있고, 메소드 별로 기능이 분류되어 있기 때문에 필요한 코드를 찾기도 쉽고 문제의 진단도 빨라진다.

그런데 프로그램이 커지면 엄청나게 많은 메소드들이 생겨나게 된다. 메소드와 변수를 관리하는 것은 점점 어려운 일이 되기 시작한다. 급기야는 메소드가 없을 때와 같은 상황에 봉착하게 된다.
그래서 객체지향이 만들어지게 되었다.

객체지향의 핵심은 <U>연관된 메소드와 그 메소드가 사용하는 변수들을 분류하고 그룹핑하는 것이다.</U> 바로 그렇게 그룹핑 한 대상이 객체(Object)다. 비유하자면 파일과 디렉토리가 있을 때 메소드나 변수가 파일이라면 이 파일을 그룹핑하는 디렉토리가 객체라고 할 수 있다. 이를 통해서 더 큰 단위의 부품을 만들 수 있게 되었다.

</br>

## 은닉화, 캡슐화
그런데 부품화라고 하는 목표는 단순히 동일한 기능을 하는 메소드와 변수를 그룹핑한다고 달성되는 것은 아니다. 제대로된 부품이라면 그것이 어떻게 만들어졌는지 모르는 사람도 그 부품을 사용하는 방법만 알면 쓸 수 있어야 한다. 이를테면 모니터가 어떻게 동작하는지 몰라도 컴퓨터와 모니터를 연결하는 방법만 알면 화면을 표시 할 수 있는 것과 같은 이치다. 즉 내부의 동작 방법을 단단한 케이스(**객체**) 안으로 숨기고 사용자에게는 그 부품(**메소드**)의 사용방법만을 노출하고 있는 것이다. 이러한 컨셉을 정보의 은닉화(Information Hiding), 또는 캡슐화(Encapsulation)라고 부른다. 자연스럽게 사용자에게는 그 부품을 사용하는 방법이 중요한 것이 된다.

> 프로그램이 객체로 이루어져 어떻게 동작하는지 몰라도 그 객체에 어떤 메소드가 들어있고, 각각에 메소드는 어떤 입력값을 갖고, 또 어떤 출력값을 갖는지, 그래서 어떻게 동작한다는 객체의 메소드 사용 방법만 알고 있으면 사용자는 그 객체들을 이용해서 더 큰 프로그램을 만들 수 있다.

</br>

## 인터페이스
잘 만들어진 부품이라면 부품과 부품을 서로 교환 할 수 있어야 한다. 예를들어보자. 집에 있는 컴퓨터에 A사의 모니터를 연결하다가 B사의 모니터를 연결 할 수 있다. 또 집에 있던 모니터에 A사의 컴퓨터를 연결해서 사용하다가 새로운 컴퓨터를 구입하면서 B사의 컴퓨터를 연결 할 수 있다. 모니터와 컴퓨터는 서로가 교환관계에 있는 것이다. 이것은 모니터와 컴퓨터를 연결하는 케이블의 규격이 **표준화** 되어 있기 때문에 가능한 일이다. 아래의 그림은 모니터와 컴퓨터를 연결하는 케이블인 HDMI이다.

![image](https://s3.ap-northeast-2.amazonaws.com/opentutorials-user-file/module/516/1860.gif)

컴퓨터와 모니터를 만드는 업체들은 위와 같은 케이블의 규격을 공유한다. 모니터 입장에서는 컴퓨터가, 컴퓨터 입장에서는 모니터가 어떤 식으로 만들어졌는지는 신경쓰지 않는다. 각각의 부품은 미리 정해진 약속에 따라서 신호를 입, 출력하고, 연결점의 모양을 표준에 맞게 만들면 된다. 이러한 연결점을 **인터페이스**(interface)라고 한다. 위의 그림을 보면 HDMI 케이블의 연결점은 특유의 생김새가 있다. 만약 HDMI 케이블을 랜선을 연결하는 구멍에 연결하려고 한다면 어떻게 될까? 동작하지 않을 뿐 아니라 연결 자체가 되지 않는다. 인터페이스란 이질적인 것들이 결합하는 것을 막아주는 역할도 하는 것이다. 즉 인터페이스는 부품들 간의 약속이다.

그래서 프로그래밍적으로 객체들을 어떻게 인터페이스가 되고 할 수 있을지 고민해야 되겠다.