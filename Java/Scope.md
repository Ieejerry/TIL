# 유효범위

</br>

## 유효범위

변수와 메소드 같은 것들을 사용할 수 있는 것은 이름이 있기 때문이다. 아래 코드에서 left는 변수의 이름이고, sum은 메소드의 이름이다.

``` java
int left;
public void sum(){}
```

프로그램이 커지면 여러 가지 이유로 이름이 충돌하게 된다. 이를 해결하기 위해서 고안된 것이 유효범위라는 개념이다. 흔히 스코프(Scope)라고도 부른다.

</br>

## 출현배경

메소드, 클래스와 같은 개념들이 등장한 배경은 프로그램을 만드는 데 사용하는 코드의 양이 기하급수적으로 증가하면서 직면하게 되는 막장을 극복하기 위한 것이었다. 거대해진 코드를 효율적으로 제어하지 못한다면 웅장한 소프트웨어를 만드는 것은 점점 불가능한 일이 될 것이다. 유효범위라는 것도 그러한 맥락에서 등장한 개념이다. 하지만 유효범위는 메소드나 클래스처럼 특별한 문법적인 규칙을 가지고 있는 것은 아니다. 오히려 메소드나 클래스 안에 포함되어서 이러한 기능들의 부품으로서의 가치를 높여주는 역할을 한다고 할 수 있다.

아래의 코드를 보자.

``` java
package scope;
 
public class ScopeDemo {
 
    static void a() {
        int i = 0;	// 메소드 안에서만 동작하는 변수 = 지역변수(Local variables)
    }	// 지역변수 선언 및 할당.
 
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {	// 지역변수 선언 및 할당.
            a();	// 메소드를 호출했지만 메소드 안에 있는 변수는 메소드 밖에서는 영향을 주지 않는다.
            System.out.println(i);	// 정상적으로 for문의 결과가 나온다.
        }
    }
 
}
```

10행에는 변수 i의 값을 기준으로 동작하는 반복문이 있다. 11행에는 메소드 a를 호출하고 있는데 메소드 a의 내부에는 변수 i의 값이 0으로 지정되고 있다. 위의 코드를 실행시킨 결과는 아래와 같다.

``` java
0
1
2
3
4
```

그런데 만약 메소드 a가 실행될 때 메소드 내부의 변수 i의 값이 반복문의 변수 i의 값을 덮어쓰게 된다면 반복문이 호출될 때마다 변수 i의 값이 0이 되기 때문에 이 반복문은 무한 반복에 빠지게 된다. 이런 상황을 해결하기 위해서는 메소드 a의 내부변수 i의 이름이나 반복문의 변수 i의 이름을 다르게 로직을 고쳐야 할 것이다.

만약 로직이 매우 복잡하거나, 메소드 a가 타인이 만든 것을 사용하는 것이라면 이것은 쉽지 않은 일이 된다. 이러한 문제는 부품으로서의 가치를 저하시킨다. 부품이란 조작 방법만 알면 내부의 동작 원리를 모르고도 사용할 수 있어야 한다. 또한, 부품 내부의 상태로 인해서 그 부품을 사용하는 외부의 동작 방법에 영향을 준다면 이 또한 좋은 부품이라고 할 수 없을 것이다.

실행결과를 보면 내부 변수의 값이 그 외부에 영향을 미치지 않는다는 것을 알 수 있다. 처음 언어를 배우는 입장에서는 이것을 그러려니 하기 쉽겠지만 그렇지 않다. 이러한 동작방법은 수 많은 시행착오를 통해서 조율된 결과라고 할 수 있다. 과거의 프로그래밍 언어는 메소드 내에서의 변수가 외부의 변수에도 영향을 미쳤기 때문에 변수나 메소드의 이름을 사무실 칠판에 적어가면서 코딩을 해야 했던 시절도 있었다. 또는 변수명을 길게 하도록 권장하거나, 심지어 변수명에 프로그래머의 이름을 적는 경우도 있었다!

이런 문제를 해결하기 위해서 다양한 시도들이 있었는데 그 노력의 결과 중의 하나가 유효범위라고 할 수 있다.

</br>

## 다양한 유효범위들

디렉터리를 생각하면 쉬울 것 같다. 처음에는 파일이 있었다. 그런데 파일이 많아지면서 파일의 이름이 충돌하기 시작한다. 파일의 사용자들은 궁여지책으로 파일의 이름에 날짜나 부서 혹은 이름을 적어서 충돌을 피했을 것이다. 이러한 문제로 인한 절망이 충분히 성숙했을 때 운영체제의 개발자들은 이를 해결하기 위한 방법에 대해서 고민을 하게 되었을 것이다. 그래서 고안된 것이 디렉터리라고 할 수 있다. 디렉터리는 파일을 그룹핑해서 그룹별로 파일을 격리한다. 디렉터리 내에서는 파일명이 중복되면 안 되지만 디렉터리 밖의 파일명과는 중복이 돼도 문제 없다. 덕분에 마음 놓고 다른 사람이 만든 파일이 담긴 디렉터리를 자신의 디렉터리로 가져올 수 있게 되었다.

위의 예제를 살펴보자. 6행에서 변수 i를 아래와 같이 선언했다.

``` java
static void a(){
    int i = 5;
}
```

이것은 변수 i가 메소드 a에 소속된 변수라는 의미다. 따라서 이 변수의 값을 어떻게 바꿔도 이 변수의 밖에는 영향을 주지 않는다.

하지만 코드를 아래와 같이 변경한다면 무한반복이 일어날 것이다.

``` java
package scope;
 
public class ScopeDemo2 {
    static int i;	// 클래스에 직접적으로 속해있는 변수는 전역변수(Global variables)이라고 한다.
    // 전역변수 선언 
    static void a() {
        i = 0;	// 전역변수 할당
    }
 
    public static void main(String[] args) {
        for (i = 0; i < 5; i++) {	// 전역변수 할당
            a();	// 전역변수를 0으로 되돌려놓음.
            System.out.println(i);	// i를 계속 0으로 되돌려 놓아서 무한반복.
        }
    }
 
}
```

변수 i가 4행에서 선언되고 있다. 4행의 변수 i는 위치적으로 어떠한 메소드의 소속도 아니다. 클래스 ScopeDemo2의 직접적인 소속인 클래스 변수다. 클래스 소속의 변수가 되면 모든 메소드에서 접근할 수 있게 된다. 그래서 7행의 변수 i는 클래스 맴버인 4행의 변수 i를 의미하게 된다. 마찬가지로 11행의 for문 안에 변수 i도 4행의 변수 i를 의미하게 된다. 다시 말해서 메소드 a의 변수 i와 for문의 변수 i가 동시에 클래스 변수 i를 사용하게 된다는 의미다. 그래서 반복문을 통해서 변수 i의 값을 아무리 바꿔도 메소드 a에 의해서 클래스 변수 i의 값이 0이 되기 때문에 반복문이 멈추지 않게 되는 것이다.

만약 위의 코드를 아래와 같이 바꾸면 위의 문제가 사라질 것이다.

``` java
package scope;
 
public class ScopeDemo3 {
    static int i;	// 전역변수 선언
     
    static void a() {
        int i = 0;	// 지역변수 선언 및 할당
    }
 
    public static void main(String[] args) {
        for (i = 0; i < 5; i++) {	// 전역변수 할당
            a();	// 지역변수는 메소드 밖에서는 영향을 주지 않음.
            System.out.println(i);	// 전역변수 i가 for문의 영향만 받아 출력.
        }
    }
 
}
```

바뀐 부분은 아래와 같다.

``` java
static void a(){
    int i = 0;
}
```

우선 메소드만 놓고 봤을 때 메소드 안에서 선언한 변수는 그 메소드가 실행될 때 만들어지고, 그 메소드가 종료되면 삭제된다. 만약 클래스 아래의 변수와 메소드 아래의 변수가 같은 이름을 가지고 있다면 메소드 아래의 변수가 우선하게 된다. 메소드 내의 변수가 존재하지 않을 때 클래스 아래의 변수를 사용하게 되는 것이다.

즉 클래스 아래에서 선언된 변수는 클래스 전역에 영향을 미치지만 메소드 내에서 선언된 변수는 클래스 아래에서 선언된 변수보다 우선순위가 높다고 할 수 있다. 지역적인 것이 전역적인 것보다 우선순위가 높다는 원칙은 특수한 것이 전체적인 것보다 우선순위가 높다는 의미로도 해석할 수 있는데 이러한 원리는 공학 전반에서 적용되는 원칙이기 때문에 교양으로서도 유익하다. 전역적으로 기본값을 설정하고, 필요에 따라서 지역 값을 다르게 사용하는 것이 더 효율적이기 때문에 이러한 원칙이 사용된다. 클래스 전역에서 접근 할 수 있는 변수를 전역변수, 메소드 내에서만 접근 할 수 있는 변수를 지역변수라고 한다. 아래 코드는 지역변수가 메소드 내에서만 접근이 가능함을 보여준다. 주석 처리된 9번라인의 주석을 제거하면 오류가 발생할 것이다. title은 메소드 a에서만 유효하기 때문이다.

``` java
package scope;
 
public class ScopeDemo4 {
    static void a(){
        String title = "coding everybody";
    }
    public static void main(String[] args) {
        a();
        //System.out.println(title);    // title 변수는 a 라는 메소드의 지역변수이기 때문에 a 메소드 밖에서는 인식할 수가 없다.
    }
 
}
```

반복문에서 정의한 변수도 반복문 밖에서는 유효하지 않다. 주석 처리된 8행의 주석을 제거하면 에러가 발생한다. 반복문에서 선언된 변수 i는 반복문 밖에서는 유효하지 않기 때문이다.

``` java
package scope;
 
public class ScopeDemo5 {
    public static void main(String[] args) {
        for (int i = 0; i < 5; i++) {	// 지역변수 i 선언 및 할당
            System.out.println(i);	// 지역변수 i 호출
        }
        // System.out.println(i);	// for문 밖에 어디에도 i가 선언되지 않았기 때문에 i를 인식하지 못함.
    }
 
}
```

조금 복잡한 예를 보자.

``` java
package scope;
 
public class ScopeDemo6 {
    static int i = 5;	// 전역변수 i 선언 및 할당
 
    static void a() {
        int i = 10;	// 지역변수 i 선언 및 할당
        b();	// 메소드 b 호출
    }
 
    static void b() {
        System.out.println(i);	// 메소드 b에서는 메소드 a의 지역변수를 인식할 수 없기 때문에 전역변수를 인식해서 출력
    }
 
    public static void main(String[] args) {
        a();	// 메소드 a 호출
    }
    // 메소드가 우선 자기 자신의 지역변수를 사용하거나, 전역변수를 사용하는 것을 정적인 유효범위(static scope, lexical scope)라고 한다.
    // 메소드가 다른 메소드의 있는 지역변수를 사용하는 것을 동적인 유효범위(dynamic scope)라고 한다.
}
```

결과는 5다. 위의 예제는 메소드 a가 메소드 b를 호출하고 있는데 메소드 b에는 변수 i의 값이 존재하지 않는다. 이 상태에서 메소드 a를 호출하면 메소드 b에서 System.out.println(i)를 했을 때 클래스 변수를 사용한다. 메소드 내(b)에서 지역변수가 존재하지 않는다면 그 메소드가 소속된 클래스의 전역변수를 사용하게 된다.

이러한 방식을 정적 스코프(static scope) 혹은 렉시컬 스코프(lexical scope)라고도 부른다. 즉 사용되는 시점에서의 유효범위(메소드 a의 i)를 사용하는 것이 아니라 정의된 시점에서의 유효범위(i = 5)를 사용하는 것이다.

> 동적 스코프라는 것도 있다. 만약 메소드 b의 결과가 10이라면 메소드 b는 메소드 a의 유효범위에 소속된 것이라고 할 수 있다. 하지만 자바는 동적 스코프를 채택하지 않고 있다. 대부분의 현대적인 언어들이 정적 스코프 방식을 선택하고 있다.

</br>

## 인스턴스의 유효범위

지금까지는 클래스 중심으로 유효범위를 알아봤다. 인스턴스에서의 유효범위도 클래스와 거의 동일하지만 결정적인 차이점은 this에 있다고 할 수 있다. 아래 예제를 보자.

``` java
package scope;
 
class C {
    int v = 10;	// 전역변수 v 선언 및 할당
 
    void m() {
        System.out.println(v);	// 전역변수 v 사용
    }
}
 
public class ScopeDemo7 {
 
    public static void main(String[] args) {
        C c1 = new C();	// 인스턴스 c1 선언 및 할당
        c1.m();	// 인스턴스 c1의 m 메소드 호출
    }
 
}
```

결과는 10이다.

아래와 같이 코드를 변경해보자.

``` java
package scope;
 
class C2 {
    int v = 10;	// 전역변수 v 선언 및 할당
 
    void m() {
        int v = 20;	// 지역변수 v 선언 및 할당
        System.out.println(v);	// 지역변수가 전역변수보다 우선순위가 높기 때문에 변수 v 사용 시 지역변수를 사용.
    }
}
 
public class ScopeDemo8 {
 
    public static void main(String[] args) {
        C2 c1 = new C2();	// 인스턴스 c1 선언 및 할당
        c1.m();	// 인스턴스 c1의 메소드 m 사용
    }
 
}
```

7행이 추가되었다. 결과는 20이다. 즉 메소드 안에서 선언된 변수 v가 지역 변수가 되면서 인스턴스 전역에서 유효한 인스턴스 변수 v의 값보다 우선순위가 높아지면서 20이 출력된 것이다.

이런 상황에서 메소드 m에서 인스턴스 변수 v에 접근하려면 this를 사용하면 된다. 아래 코드를 보자.

``` java
package scope;
 
class C3 {
    int v = 10; // 전역변수 v 선언 및 할당
 
    void m() {
        int v = 20; // 지역변수 v 선언 및 할당
        System.out.println(this.v); // 전역변수 v 사용(this는 인스턴스 자기 자신을 뜻함. 즉, this.v는 전역변수v를 뜻함.)
    }
}
 
public class ScopeDemo9 {
 
    public static void main(String[] args) {
        C3 c1 = new C3();   // 인스턴스 c1 선언 및 할당
        c1.m(); // 인스턴스 c1의 메소드 m 사용
    }
 
}
```

7행이 this.v로 바뀌었다. 그 결과 메소드 m 안에서 인스턴스 변수 v를 사용할 수 있게 되었다. this는 인스턴스 자신을 의미하는 키워드라고 할 수 있다.

</br>

## 교훈

유효범위란 변수를 전역변수, 지역변수 나눠서 좀 더 관리하기 편리하도록 한 것이다. 객체라는 개념이 존재하지 않는 절차지향 프로그래밍에서는 모든 메소드에서 접근이 가능한 변수(전역변수)의 사용을 죄악시하는 경향이 있다. 전역적인 사용의 효용이 분명한 데이터에 한해서 제한적으로 전역변수를 사용하도록 하고 있는 것이다. 객체지향 프로그래밍은 바로 이런 문제를 극복하기 위한 노력이라도고 볼 수 있다. 즉 연관된 변수와 메소드를 그룹핑 할 수 있도록 함으로서 좀 더 마음놓고 객체 안에서 전역변수를 사용할 수 있도록 한 것이다. 전역변수는 더 이상 죄악시할 대상이 아닌 것이 된다. 이렇듯 도구와 사람의 마음은 밀접한 연관이 있다.

부품의 관점에서도 생각해볼 수 있다. 어떤 메소드가 전역변수를 사용하고 있다는 것은 그 메소드는 그 전역변수에 의존한다는 의미다. 전역변수에 의존한다는 것은 이 메소드가 다른 완제품의 부품으로서 사용될 수 없다는 의미다. 객체지향 덕분에 좀 더 안심하고 전역변수를 사용하게 되었지만, 객체도 크기가 커지면 관리의 이슈가 생겨난다. 객체지향 프로그래밍에서도 가급적이면 전역변수의 사용을 자제하는 것이 좋고, 동시에 단일 객체가 너무 비대해지지 않도록 적절하게 규모를 쪼개는 것도 중요하다.